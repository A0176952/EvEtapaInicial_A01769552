# -*- coding: utf-8 -*-
"""MLE_A01769552

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TNIbZ2wspXBjwR8Smi05PCZGHQHW4B6V
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import beta
from scipy.stats import norm
import scipy.stats as stats

"""Importamos el archivo como dataframe."""

df = pd.read_csv('SuperMarketData.csv')
df.head()

"""Convertimos las ventas de dolares a pesos"""

sales=np.array(df["Sales"])*19.88

"""Sacamos mínimos y máximos de nuestro df"""

max_sales=max(sales)
min_sales=min(sales)
sales_norm=1/(max_sales-min_sales)*(sales-min_sales)

"""Aqui tenemos un Histograma que representa la distribución de los ratings de manera gráfica, de esta no podemos ver si la distribución es normal tan fácilmente, por lo que podemos intentar aumentar el número de "bins" para ver si la distribución obtiene un patron con el que podamos obtener una base sólida."""

plt.figure(figsize=(10, 6))
plt.hist(df['Rating'], bins=10, edgecolor='black')
plt.title('Distribución de los datos')
plt.xlabel('Rating')
plt.ylabel('Frecuencia')
plt.grid(axis='y', linestyle='--', alpha=0.9)
plt.show()

"""Como creemos sensato asumir que nuestros datos siguen una distribución beta, podemos usar la siguiente función para obtener los parametros alpha y beta, que nos ayudarán a obtener los parámetros necesarios que nos ayudarán a llevar a cabo nuestro ptoyecto."""

a,b,_,_=beta.fit(sales)

print(a,b)

"""Utilizamos estos valores para crear nuevas variables qu enos ayudarán a ajustar nuestros parámetros a nuestra función beta."""

mu_norm = a/(a+b)
var_norm = a*b/((a+b)**2*(a+b+1))
dev_norm = np.sqrt(var_norm)

"""Una vez obtenidos los parámetros necesarios para poder ajustar nuestros valores podemos generar nuestros mu y nuestra varianza, la razon por la que hicimos esto es para que se adapten a nuestro rango de la función beta, cuyo rango va de 0 hasta 1."""

mu = (max_sales-min_sales)*mu_norm+min_sales
var = (max_sales-min_sales)**2*var_norm
dev = np.sqrt(var)

"""Gastos de operación, estos son todos los gastos que hay para mantener a nuestra sucursal en un día regular, hay que tener en cuenta que para todos los trabajadores cuyo ingreso es el salario mínimo, deseamos pagarles 15% más."""

sal_cajeros = 258.25
num_cajeros = 30
dias_t = 24

sal_conserje = 5000
num_conserjes = 20

sal_gerente = 100000

sal_sgerente = 45000
num_sgerentes = 4

sal_almacenista = 262.13
num_almacenistas = 40

sal_pasillo = 264.65
num_pasillos = 40

fact = 1.15

nomina_sg = (sal_cajeros*num_cajeros*dias_t+sal_conserje*num_conserjes+dias_t*sal_almacenista*num_almacenistas+dias_t*sal_pasillo*num_pasillos)*fact
nomina_tot = nomina_sg+sal_sgerente*num_sgerentes+sal_gerente
nomina_tot

"""Gasto de luz"""

gasto_luz = 120*2000*12*2.3*30
gasto_luz

gasto_tot = nomina_tot+gasto_luz
gasto_tot

omega = norm.ppf(.01)
sigma = np.sqrt(var)
ingreso = gasto_tot+1500000

a_= mu**2
b_ = -2*mu*ingreso-omega**2*sigma**2
c_ = gasto_tot**2

N1=(-b_+np.sqrt(b_**2-4*a_*c_))/(2*a_)
N2=(-b_-np.sqrt(b_**2-4*a_*c_))/(2*a_)

print(N1)
print(N2)

if(ingreso/N1-mu>0):
  N = N1
else:
  N = N2

print(N)

porc_pob=N/160000
print(porc_pob)

"""La distribución que tienen los ratings es uniforme, puesto que estan dispersos de igual manera en todos los rangos, es por eso que podemos utilizar la función beta para normalizar nuestros datos y poder utilizar MLI.

Mejora de Análisis
"""

sal_cfarmacia = 300.84*24
num_cfarmacias = 4

sal_choferescarga = 293.06*24
num_choferescarga = 5

sal_montacargas = 253.10*24
num_montacargas = 2

sal_seguridad = 5703
num_seguridad = 6

aux_protección = 7279

m3 = 2000*10
gasto_agua=m3*329.82

gasto_tot = gasto_tot+sal_cfarmacia*num_cfarmacias+sal_choferescarga*num_choferescarga+sal_montacargas*num_montacargas+sal_seguridad*num_seguridad+aux_protección+gasto_agua
gasto_tot

"""¿Cual es la probabilidad de haya un rating de 8.5 o más?"""

rating=np.array(df["Rating"])
max_rating=max(rating)
min_rating=min(rating)
rating_norm=1/(max_rating-min_rating)*(rating-min_rating)

a_rating,b_rating,_,_=beta.fit(rating)
mu_ratingN = (max_rating-min_rating)*a_rating+min_rating
var_ratingN = (max_rating-min_rating)**2*b_rating

mu_rating = (max_rating-min_rating)*mu_ratingN+min_rating
var_rating = (max_rating-min_rating)**2*var_ratingN
dev_rating = np.sqrt(var_rating)

n=1000
rating_obj=8.5

Z = (rating_obj-mu_rating)/(dev_rating/np.sqrt(n))

P = norm.cdf(Z)
print(P)